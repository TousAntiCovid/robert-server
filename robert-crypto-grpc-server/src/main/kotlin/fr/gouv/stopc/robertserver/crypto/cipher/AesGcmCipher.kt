package fr.gouv.stopc.robertserver.crypto.cipher

import java.security.Key
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec

private const val AES_GCM_CIPHER_SCHEME = "AES/GCM/NoPadding"
private const val AES_GCM_IV_LENGTH = 96
private const val AES_GCM_AUTH_TAG_LENGTH = 128

fun ByteArray.encryptUsingAesGcm(secretKey: Key) = AesGcmCipher(secretKey).encrypt(this)

fun String.encryptUsingAesGcm(secretKey: SecretKey) = this.toByteArray().encryptUsingAesGcm(secretKey)

fun ByteArray.decryptUsingAesGcm(secretKey: Key) = AesGcmCipher(secretKey).decrypt(this)

class AesGcmCipher(private val secretKey: Key) : RobertCipher {

    override fun encrypt(clearData: ByteArray): ByteArray {
        val cipher = Cipher.getInstance(AES_GCM_CIPHER_SCHEME).apply {
            init(Cipher.ENCRYPT_MODE, secretKey)
        }
        // Prepend random 96-bit IV that was generated by Java
        return cipher.iv + cipher.doFinal(clearData)
    }

    override fun decrypt(encryptedData: ByteArray): ByteArray {
        val iv = encryptedData.take(AES_GCM_IV_LENGTH / 8).toByteArray()
        val payload = encryptedData.drop(AES_GCM_IV_LENGTH / 8).toByteArray()
        val algorithmParameterSpec = GCMParameterSpec(AES_GCM_AUTH_TAG_LENGTH, iv)
        val cipher = Cipher.getInstance(AES_GCM_CIPHER_SCHEME).apply {
            init(Cipher.DECRYPT_MODE, secretKey, algorithmParameterSpec)
        }
        return cipher.doFinal(payload)
    }
}
