package e2e.external.crypto;

import e2e.external.common.utils.ByteUtils;
import e2e.external.crypto.exception.RobertServerCryptoException;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Objects;

@Slf4j
public abstract class CryptoCipherStructureAbstract implements ICryptoStructure, ICipherStructure {

    /**
     * @param
     * @return A byte[] with the cipher text and additional info. e.g. for
     *         AES256-GCM, size 12 (IV) + plainText.length + 16 (GCM tag)
     */
    @Override
    public byte[] encrypt(byte[] plainText) throws RobertServerCryptoException {
        try {
            AlgorithmParameterSpec algoSpec = this.getAlgorithmParameterSpec();

            byte[] cipherText;
            if (Objects.nonNull(algoSpec)) {
                this.getCipher().init(Cipher.ENCRYPT_MODE, this.getSecretKey(), algoSpec);
                cipherText = this.getCipher().doFinal(plainText);
            } else {
                this.getCipher().init(Cipher.ENCRYPT_MODE, this.getSecretKey());
                // Prepend random 96-bit IV that was generated by Java

                byte[] iv = null;
                try {
                    iv = this.getCipher().getIV();
                } catch (Exception e) {
                    log.warn("Error retrieving iv; trying without");
                }

                cipherText = ByteUtils.addAll(iv, this.getCipher().doFinal(plainText));
            }

            return cipherText;
        } catch (IllegalBlockSizeException | BadPaddingException | InvalidKeyException
                | InvalidAlgorithmParameterException e) {
            throw new RobertServerCryptoException(e);
        }
    }

    @Override
    public byte[] decrypt(byte[] cipherText) throws RobertServerCryptoException {
        try {
            return this.getDecryptCypher().doFinal(cipherText);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            throw new RobertServerCryptoException(e);
        }
    }

}
