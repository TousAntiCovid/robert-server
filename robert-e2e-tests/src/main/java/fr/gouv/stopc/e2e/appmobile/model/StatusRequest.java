package fr.gouv.stopc.e2e.appmobile.model;

import fr.gouv.stopc.e2e.appmobile.EpochClock;
import fr.gouv.stopc.e2e.external.common.enums.DigestSaltEnum;
import fr.gouv.stopc.e2e.external.common.utils.ByteUtils;
import fr.gouv.stopc.e2e.external.crypto.CryptoHMACSHA256;
import lombok.Builder;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;

import java.util.Base64;

import static fr.gouv.stopc.e2e.external.common.utils.ByteUtils.addAll;
import static fr.gouv.stopc.e2e.external.common.utils.ByteUtils.longToBytes;

/**
 * The StatusRequest structure is:
 *
 * <pre>
 *     +----------------------------------------------------------------+
 *     |                    StatusRequest (128 bits)                    |
 *     +----------------------------------------------------------------+
 *     | EBID          | EpochId       | Time           | MAC           |
 *     |     (64 bits) |      (8 bits) |      (16 bits) |     (32 bits) |
 *     +----------------------------------------------------------------+
 * </pre>
 *
 * @see <a href=
 *      "https://github.com/ROBERT-proximity-tracing/documents/blob/master/ROBERT-specification-EN-v1_1.pdf">Robert
 *      Protocol 1.1</a> ยง7 Exposure Status Request (ESR)
 */
@Value
@Builder
@Slf4j
public class StatusRequest {

    /**
     * The epoch identifier (8 bits)
     */
    int epochId;

    /**
     * Ephemeral Bluetooth ID at epoch i, generated by the back-end (64 bits)
     */
    byte[] ebid;

    /**
     * Status Request generation time.
     */
    byte[] time;

    /**
     * mac = HMAC -SHA256(KA; c2 j EBIDA;i j Time)]
     */
    byte[] mac;

    @Override
    public String toString() {
        final var base64 = Base64.getEncoder();
        final var ebidB64 = base64.encodeToString(ebid);
        final var macB64 = base64.encodeToString(mac);
        final var timeB64 = base64.encodeToString(time);
        return String
                .format("StatusRequest(epoch=%s, ebid=%s, time=%s, mac=%s)", epochId, ebidB64, timeB64, macB64);
    }

    public static StatusRequest.StatusRequestBuilder builder(DigestSaltEnum digestSalt,
            byte[] macKey, EpochClock.RobertInstant time) {
        final var macCipher = new CryptoHMACSHA256(macKey);
        return new StatusRequest.StatusRequestBuilderWithMac(digestSalt, macCipher, time);
    }

    @RequiredArgsConstructor
    public static class StatusRequestBuilderWithMac extends StatusRequest.StatusRequestBuilder {

        private final DigestSaltEnum digestSalt;

        private final CryptoHMACSHA256 macCipher;

        private final EpochClock.RobertInstant time;

        @Override
        public StatusRequest.StatusRequestBuilder mac(byte[] mac) {
            throw new UnsupportedOperationException(
                    "'mac' is an attributed derived from 'ebid', 'epochId' and 'time' using builder's 'macKey'"
            );
        }

        public StatusRequest build() {
            final var original = super.build();
            final var ebid = original.getEbid();
            final var epochId = time.getEpochId();

            // Keep 4 significant bytes
            final var tsInSeconds = longToBytes(time.asNtpTimestamp());
            var byteDate = new byte[4];
            System.arraycopy(tsInSeconds, 4, byteDate, 0, 4);

            // Compute MAC
            var agg = new byte[ebid.length + Integer.BYTES + byteDate.length];
            System.arraycopy(ebid, 0, agg, 0, ebid.length);
            System.arraycopy(ByteUtils.intToBytes(epochId), 0, agg, ebid.length, Integer.BYTES);
            System.arraycopy(byteDate, 0, agg, ebid.length + Integer.BYTES, byteDate.length);

            byte[] mac = new byte[32];
            try {
                mac = this.generateHMAC(
                        macCipher, agg, digestSalt
                );
            } catch (Exception e) {
                throw new RuntimeException("Problem generating SHA256", e);
            }
            return new StatusRequest(epochId, ebid, byteDate, mac);
        }

        @SneakyThrows
        private byte[] generateHMAC(final CryptoHMACSHA256 cryptoHMACSHA256S, final byte[] argument,
                final DigestSaltEnum saltEnum) {
            return cryptoHMACSHA256S.encrypt(addAll(new byte[] { saltEnum.getValue() }, argument));
        }
    }
}
