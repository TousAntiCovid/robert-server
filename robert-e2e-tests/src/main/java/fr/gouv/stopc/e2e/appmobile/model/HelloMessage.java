package fr.gouv.stopc.e2e.appmobile.model;

import fr.gouv.stopc.e2e.external.common.enums.DigestSaltEnum;
import fr.gouv.stopc.e2e.external.common.utils.TimeUtils;
import fr.gouv.stopc.e2e.external.crypto.CryptoHMACSHA256;
import fr.gouv.stopc.e2e.external.crypto.exception.RobertServerCryptoException;
import lombok.Builder;
import lombok.RequiredArgsConstructor;
import lombok.Value;

import java.time.Instant;
import java.util.Arrays;
import java.util.Base64;

import static fr.gouv.stopc.e2e.external.common.utils.ByteUtils.longToBytes;

/**
 * The HelloMessage structure is:
 *
 * <pre>
 *     +----------------------------------------------------------------+
 *     |                    HelloMessage (128 bits)                     |
 *     +----------------------------------------------------------------+
 *     | ECC          | EBID           | Time           | MAC           |
 *     |     (8 bits) |      (64 bits) |      (16 bits) |     (40 bits) |
 *     +----------------------------------------------------------------+
 * </pre>
 *
 * @see <a href=
 *      "https://github.com/ROBERT-proximity-tracing/documents/blob/master/ROBERT-specification-EN-v1_1.pdf">Robert
 *      Protocol 1.1</a> §5
 */
@Value
@Builder
public class HelloMessage {

    /**
     * Ephemeral Bluetooth ID at epoch i, generated by the back-end (64 bits)
     */
    byte[] ebid;

    /**
     * The encrypted country code (8 bits)
     */
    byte[] ecc;

    /**
     * Hello Message generation time. Here it is a high definition timestamp but the
     * value sent to Robert API Server is obtain using {@link #getEncodedTime()}.
     */
    Instant time;

    /**
     * a HMAC − SHA256(KA,c1 | MA,i) truncated to 40 bits (c1 is the 8-bit prefix
     * ”01”)
     */
    byte[] mac;

    public ContactTuple getContactTuple() {
        return new ContactTuple(ebid, ecc);
    }

    /**
     * @return 16-bit timestamp (to encode the fine-grain emission time). It
     *         contains the 16 less significant bits of the current NTP "Seconds"
     *         timestamp
     */
    public byte[] getEncodedTime() {
        // compute 16 less significant bits of the HelloMessage NTP time
        final var timeAsNtpSeconds = TimeUtils.convertUnixMillistoNtpSeconds(time.toEpochMilli());
        final var timeLessSignificantBytes = new byte[4];
        System.arraycopy(longToBytes(timeAsNtpSeconds), 4, timeLessSignificantBytes, 0, 4);
        // Clear out the first two bytes
        timeLessSignificantBytes[0] = 0x00;
        timeLessSignificantBytes[1] = 0x00;
        return timeLessSignificantBytes;
    }

    @Override
    public String toString() {
        final var base64 = Base64.getEncoder();
        final var ebidB64 = base64.encodeToString(ebid);
        final var eccB64 = base64.encodeToString(ecc);
        final var macB64 = base64.encodeToString(mac);
        return String.format("HelloMessage(ebid=%s, ecc=%s, time=%s, mac=%s)", ebidB64, eccB64, time, macB64);
    }

    public static HelloMessageBuilder builder(DigestSaltEnum digestSalt, byte[] macKey) {
        final var macCipher = new CryptoHMACSHA256(macKey);
        return new HelloMessageBuilderWithMac(digestSalt, macCipher);
    }

    @RequiredArgsConstructor
    public static class HelloMessageBuilderWithMac extends HelloMessageBuilder {

        private final DigestSaltEnum digestSalt;

        private final CryptoHMACSHA256 macCipher;

        @Override
        public HelloMessageBuilder mac(byte[] mac) {
            throw new UnsupportedOperationException(
                    "'mac' is an attributed derived from 'ebid', 'ecc' and 'time' using builder's 'macKey'"
            );
        }

        public HelloMessage build() {
            final var original = super.build();
            final var ebid = original.getEbid();
            final var ecc = original.getEcc();
            final var time = original.getTime();
            final var timeMostSignificantBits = original.getEncodedTime();

            // Merge arrays
            final var mai = new byte[1 + ebid.length + ecc.length + 2];
            System.arraycopy(new byte[] { digestSalt.getValue() }, 0, mai, 0, 1);
            System.arraycopy(ecc, 0, mai, 1, ecc.length);
            System.arraycopy(ebid, 0, mai, 1 + ecc.length, ebid.length);
            System.arraycopy(timeMostSignificantBits, 2, mai, 1 + ecc.length + ebid.length, 2);

            try {
                final var entireMac = macCipher.encrypt(mai);
                // Truncate the result from 0 to 40-bits
                final var mac = Arrays.copyOfRange(entireMac, 0, 5);
                return new HelloMessage(ebid, ecc, time, mac);
            } catch (RobertServerCryptoException e) {
                throw new IllegalStateException("error computing the HMAC for " + original, e);
            }
        }
    }
}
